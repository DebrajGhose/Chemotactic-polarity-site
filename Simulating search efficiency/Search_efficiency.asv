%% Simulate search efficiency

clear all
close all
sprintf(['\n']) %create some white space for better readability

simulate_search_efficiency = 1; %see how efficient different search methods are
create_figure_of_cells_searching = 0; %create a figure for particles moving along surface of a sphere


%% Set up colors


newcolors = [ 203 91 90;...
    0 0 0;...
    83 187 110;...
    130 172 162;...
    76 180 209;...
    45 112 178;
    26 110 38]/255; 


%{

newcolors = [ 225 151 76 ;... %orange
    0 0 0 ;... %black
    114 147 203 ;... %blue
    132 186 91 ;... %green
    144 103 167 ; ... %purple
    171 104 87 ;... %maroon
    211 94 96 ;... %red
    128 133 133;...%gray
    204 194 16]/255; %gold

%}

set(groot,'defaultAxesColorOrder',newcolors)



%% Simulate patch movment on spheres that are near each other
%
%         Adjacent wandering cells                                    Time
%                                                                              XXX
%                                                                             XXX            +
%                                                              +           XXX               |
%      XXXXXXXXXXXXX           XXXXXXXXX                       |          XX                 |        X
%    XXX           XX       XXX        XXX                     |         X                   |
%  X X              XX     XX            XXX                   |        X                    |
% XX                 XX    X               X                   |      XX        XXX          |
% X             XXXX   X  XX               XXX                 |     XX      XXXX            |
% X             XXXXX  X  X      XX  XXXX    X                 |    XX     XXX               |                 X
% X   XXX      XXXXX  X   X    XXXXX X   X   XX                |   XX   XXX                  |   X
% XXXX   XXXXXX       X   XX    XXX XX   X    X                |  XX  XX         XXXXX       |
%  XX                 X    X           XXX   XX                | X  XX      XXXXX            |
%  XX               XXX    XX        XX     XX                 |X X X   XXXX                 |
%    XX            XX       XXX      X    XX                   |XXXXX                        |
%     XXXXXXXXXXXXX           XXXXXXXXXXXX                     +-----------------------+     +----------------------+
%                                                                         time                        angles

if simulate_search_efficiency == 1
    
    simulationtype = 1;
    % 1. simulate patch movement by sampling/modeling r and theta from offset Gaussian
    % 2. simulate patch movement by modeling theta from experiment but r from a gaussian that was generated by fitting experimental msd
    % 3. simulate patch movement by sampling r and theta from the large PDE model
    
    if simulationtype == 1
        
        myparameters = [0.9];        
        
    elseif simulationtype == 2
        
        myparameters = [0];
        
    elseif simulationtype == 3
        
         myparameters = {'insilico_20190113_G_SETMAWP_k_gauss_1_5_actinvar_024_LocalGAP_thalf_10_GAP_0_clusteredvesicle_LtH_100_HtL_20_LR_100',...
            'insilico_20190113_G_SETMAWP_k_gauss_0_actinvar_024_LocalGAP_thalf_10_GAP_0_clusteredvesicle_LtH_100_HtL_20_LR_50',...
            'insilico_20190113_G_SETMAWP_k_gauss_0_actinvar_024_LocalGAP_thalf_10_GAP_0_3_clusteredvesicle_LtH_100_HtL_20_LR_100',...
            'insilico_20190113_G_SETMAWP_k_gauss_0_actinvar_024_LocalGAP_thalf_10_GAP_0_clusteredvesicle_LtH_100_HtL_20_LR_100',...
            'insilico_20190113_G_SETMAWP_k_gauss_1_5_actinvar_024_LocalGAP_thalf_10_GAP_0_3_clusteredvesicle_LtH_100_HtL_20_LR_50'};
    end
    
    
    for parameter =  myparameters %sweep through some parameter -- you can change what the parameter is
        
       
        cellradius = 2.5; %microns
        startpositions = [ 1 , -1 ]; %parameters that determine two positions where you want the patches to start
        numbsteps = 100; %number of simulations steps you want this to take
        numbsims = 5000; %number of cells you want to simulate
        
        
        timeinterval = 2; %minutes
        
        sphere_paths = cell(numbsims,numel(startpositions));
        
        if simulationtype == 1 || simulationtype == 2
            
            load('InVivo_same.mat');
            convertedrs = real(cellradius*acos(1 - allrs.^2/(2*cellradius^2))); % since these are all straight lines, convert to how far a point would have traveled on a sphere of some radius
            
            
            if simulationtype == 1 %establish values for amp, sigma, and uni
                %amp = 1;
                %sigma = 0.9;
                uni = 0.2;
                
                normfunctionexp = @(x) 1*exp( -(x).^2/(2*0.9^2) ); %use this to find area of gaussian part of 'offset gaussian' that fits experimental data.
                %Recall that  amp = 1, sigma = 0.9, and uni = 0.2 seems to match turning angle distribution seen in experiments.
                angareaexp = integral(normfunctionexp,-pi,pi);
                
                normfunction = @(x) 1*exp( -(x).^2/(2*parameter^2) ); %use this to calibrate 'amp' so that area is the same
                angarea = integral(normfunction,-pi,pi);
                
                amp = angareaexp/angarea; %new amp value
                
            end
            
        elseif simulationtype == 3
            
            load(char(parameter));
            
        end
        
        %convertedrs = allrs;
        if 0 %open flag if you want to simulate stuff
            
            for sim = 1:numbsims
                
                for startat = 1:numel(startpositions) %start with patch on back half of each spherical cell
                    
                    storedpath = zeros(numbsteps,3); % initialize martix where you will store patch path
                    
                    %generate a point uniformly on spherical cell
                    
                    az = 2*pi*rand();
                    ele = asin(2*rand()-1);
                    [Xc,Yc,Zc] = sph2cart(az,ele,cellradius);
                    
                    storedpath(1,:) = [ Xc,Yc,Zc ];
                    
                    
                    for iindex = 2:numbsteps
                       
                        if simulationtype == 1
                            
                            %simulate experimental cell's movement with both r and theta
                            ang = Function_sample_normal_uniform( amp , parameter , uni ); % amp = 1, sigma = 0.9, and uni = 0.2 seems to match turning angle distribution seen in experiments
                            mydist = randsample(convertedrs,1);
                            
                        elseif simulationtype == 2
                            
                            %simulate same thing but using theta from experiments and r from a gaussian that was chosen by fitting msd to experimental data
                            ang = rand()*2*pi-pi; %sample with no persistence
                            mydist = abs(normrnd(0,sqrt(4*0.0971*timeinterval))); %0.0971 um^2/min is the diffusion constant extracted from simulated persistent movement from in vivo data
                            
                        elseif simulationtype == 3
                            
                            %simulate by sampling r and theta from the PDE
                            ang = randsample(diffangs(:),1);
                            mydist = randsample(vectr(:),1);
                            
                        end
                        
                        [storedpath] = Function_sphere_walk( mydist , ang , storedpath , iindex , cellradius); %simulate 'walking' patch
                        
                    end
                    
                    storedpath = storedpath + [ -startpositions(startat)*cellradius 0 0 ]; %move the entire sphere away from the center
                    
                    sphere_paths{sim,startat} = storedpath;
                    
                end
                
            end
            
        end
        
        if 0 %open flag if you want to generate figure or graphic of paths on adjacent spheres
            %%
            figure
            
            p1 = sphere_paths{7,1}; p2 = sphere_paths{7,2}; % grab two paths on spheres
            
            plot3(p1(:,1),p1(:,2),p1(:,3))
            hold on
            plot3(p2(:,1),p2(:,2),p2(:,3))
            
            [x,y,z] = sphere;
            
            x = cellradius*x; y = cellradius*y; z = cellradius*z;
            
            surf(x+cellradius,y,z,'FaceColor',[0.6 0.6 0.6] , 'EdgeColor' , 'none' , 'Facealpha' , 0.3);
            surf(x-cellradius,y,z,'FaceColor',[0.6 0.6 0.6] , 'EdgeColor' , 'none' , 'Facealpha' , 0.3);
            
            axis equal
            view([0 0]);
            axis off
            set(gcf ,'renderer' ,'painters') %do this or matlab will fucking fail to generate a vector graphic
            
        end
        %%
        if 1 %open flag if you want to analyze simulations for search efficiency
            %%
            
            shouldiboot = 1; %decide on whether you want to bootstrap from simulations
            
           
            if shouldiboot == 1, bootstrapnum = 100; else, bootstrapnum = 1; end
            
            all_enc_distances = [1 4];
            
            
            %start by plotting Same sex search efficiency
            
            load('Same_invivo_distances.mat') % Cumulative plots for in vivo distances
            
            for enc_distance = all_enc_distances %encounter distance in microns
                 
                searcheff = []; checktime = 80; %store simunation search efficiencies and time at which you want to check search efficiencies
                
                cum = 0;
                cumplot = [];
                dists = Samedists; %copy into dists matrix to preserve it
                
                for ii = 1:size(Samedists,1)
                    
                    withindist = find(dists(ii,:)<enc_distance); %find which cells are within encounter distance for timepoint ii
                    
                    cum = cum + numel(withindist)/size(Samedists,2); %Divide by total number of cells
                    
                    cumplot = [cumplot , cum ];
                    
                    dists(:,withindist) = []; %remove cells that have already found each other
                    
                end
                
                timeaxis = ((1:numel(cumplot))-1)*timeinterval;
                
                samesearch = interp1(timeaxis,cumplot,checktime);
                hold on
                plot( timeaxis ,  cumplot ,'r' )
                
                expstart = cumplot(1); %the value you want to adjust your simulations with
                
                
                
                
                %bootstrap from simulations to plot serach efficiencies
                
                for booti = 1:bootstrapnum %bootstrap index from data
                    
                    
                    
                    load('InSilico_same.mat'); %do the analysis with in silico cells first
                    
                    if shouldiboot == 1, sphere_paths = sphere_paths(randperm(size(sphere_paths,1),52),:); end %if you want to bootstrap, select some random paths
                    
                    
                    timeofenc = nan(size(sphere_paths,1),1);
                    
                    for cellind = 1:size(sphere_paths,1)
                        
                        dists = Function_find_dist(sphere_paths{cellind,1},sphere_paths{cellind,2});
                        
                        if ~isempty(find(dists<enc_distance,1,'first'))
                            
                            timeofenc(cellind) = find(dists<enc_distance,1,'first');
                            
                        else
                            
                            timeofenc(cellind) = Inf; %insert an arbitrarily high number
                            
                        end
                        
                    end
                    
                    hold on
                    
                    dx = 0.1;
                    
                    hold on
                    mycdf = cdfplot(timeofenc*timeinterval);
                    cdfx = mycdf.XData(1:2:end); cdfy = mycdf.YData(1:2:end) ;
                    cdfy = cdfy-cdfy(2)+expstart; %this is to make it similar to experimiental starting position
                    plot( cdfx-timeinterval , cdfy , 'Color' , [0.6 0.6 0.6] )
                    searcheff = [ searcheff , interp1( cdfx(2:end-1) , cdfy(2:end-1) , checktime ) ]; %keep track of what search efficiency was close to 60
                    delete(mycdf)
                    %mycdf.Color = [0.6 0.6 0.6]; %change color to gray
                    xlim([0 80])
                    ylim([0 1])
                    xlabel('Time (min)'); ylabel('Cumlative Frequency');
                    axis square
                    
                end
                
                
                %see who many simulations search fellas got above or below same search fellas
            
            fprintf('Proportion of simulations (%d microns) below\n same sex in vivo search efficiency is %d \n', enc_distance , sum(searcheff<samesearch)/numel(searcheff) );
            
            spara = fitdist(searcheff','normal');
            
            disp(pdf('Normal',spara.mu,spara.sigma,samesearch))
                
            end
            
           
            
            
            
            
            %disp(sum((finaltimes>cumplot))/bootstrapnum);
            
            %{n
            
             load('Opp_invivo_distances.mat') % Cumulative plots for in vivo distances
            
            for enc_distance = all_enc_distances %encounter distance in microns
                
                cum = 0;
                cumplot = [];
                dists = Oppdists; %copy into dists matrix to preserve it
                
                
                for ii = 1:size(Oppdists(:,1),1)
                   
                    withindist = find(dists(ii,:)<enc_distance); %find which cells are within encounter distance
                    
                    cum = cum + numel(withindist)/numel(Oppdists(1,:));
                    
                    cumplot = [cumplot , cum ];
                    
                    dists(:,withindist) = []; %remove cells that have already found each other
                    
                end
                
                plot( ((1:numel(cumplot))-1)*timeinterval ,  cumplot ,'b' )
                
            end
            %}
            
        end
        %%
        if 0 % calculate diffusion constant of your moving particle on a sphere
            
            squaresum = zeros(size(sphere_paths{1},1),1); %store all summed squares here
            
            for cellind = 1:size(sphere_paths,1)
                
                mypath = sphere_paths{cellind,1}; mypath = mypath + [-cellradius 0 0];
                disttraveled = zeros(size(mypath,1),1); %store greatest circle distances traveled from initial location here
                
                for pointtime = 1:size(mypath,1)
                    
                    disttraveled(pointtime) = cellradius * atan2(norm(cross(mypath(1,:),mypath(pointtime,:))),dot(mypath(1,:),mypath(pointtime,:)));
                    
                    %disttraveled(pointtime) = Function_find_dist( mypath(1,:) , mypath(pointtime,:)     );
                    
                end
                
                squaresum = squaresum + disttraveled.^2;
                
            end
            
            extractedmsd = squaresum/size(sphere_paths,1);
            timeaxis = [(1:numbsteps) - 1 ]'*timeinterval;
            
            figure
            fitlimit = 8;
            
            plot(timeaxis,extractedmsd,'.')
            xlim([0 fitlimit*timeinterval]);
            
            para = polyfit(timeaxis(1:fitlimit),extractedmsd(1:fitlimit),1);
            
            disp(para(1)/4);
            
            hold on
            
            plot(timeaxis,timeaxis*para(1) + para(2))
        end
        
        
        if 0 %plotting persistence from simulated storedpath and comparing with experimental data
            
            simangles = []; %store all angles here
            diffvects  = storedpath(2:end,:) - storedpath(1:end-1,:);
            
            allrs = sqrt(sum(diffvects.^2,2));
            
            for j = 2:size(diffvects,1)
                
                diffang = atan2(norm(cross(diffvects(j,:),diffvects(j-1,:))), dot(diffvects(j,:),diffvects(j-1,:))); %find difference in angle
                simangles = [simangles, diffang];
                
            end
            subplot(1,2,1)
            hold on
            cdfplot(simangles); %simulation angles
            cdfplot(allangs); %experimental angles
            
            xlabel('Turning Angle')
            
            subplot(1,2,2)
            hold on
            cdfplot(allrs);
            
        end
    end
    
    if simulationtype==3
        legend(myparameters)
    end
    
end


%% Generate illustration of cells searching for each other by making their patches wander

if create_figure_of_cells_searching == 1
    
    cellradius = 2.5;
    
    load('Gammastuff_0.mat')
    cellpair = 9;
    p1 = sphere_paths{cellpair,1}; p2 = sphere_paths{cellpair,2}; % grab two paths on spheres
    
    plot3(p1(:,1),p1(:,2),p1(:,3))
    hold on
    plot3(p2(:,1),p2(:,2),p2(:,3))
    
    [x,y,z] = sphere;
    
    x = cellradius*x; y = cellradius*y; z = cellradius*z;
    
    surf(x+cellradius,y,z,'FaceColor',[0.6 0.6 0.6] , 'EdgeColor' , 'none' , 'Facealpha' , 0.3);
    surf(x-cellradius,y,z,'FaceColor',[0.6 0.6 0.6] , 'EdgeColor' , 'none' , 'Facealpha' , 0.3);
    
    axis equal
    view([0 0]);
    axis off
    set(gcf ,'renderer' ,'painters') %do this or matlab will fucking fail to generate a vector graphic
    
    
    %myp = sphere_paths{cellpair,2};
    
    %plotOnSphere(myp(:,1) , myp(:,2) , myp(:,3) )
    
    
    
end






%% Functions

%% function to generate curved lines on spherical surface




function plotOnSphere(x,y,z)

%// Vectors representing each point
xyz = [x(:), y(:), z(:)].';  %'

%// One vector of the "first" points and one of the "next" points
v1 = xyz(:, 1:end-1);
v2 = xyz(:, 2:end);

%// Cross product between the vectors of one point and the next
cv1v2 = cross(v1, v2);

%// Compute unit vector in the plane defined by v1 and v2
v3 = normc(cross(cv1v2, v1));

%// Figure out the range of the inner angle between v1 and v2
nc = sqrt(sum(cv1v2.^2, 1));
t = atan2(nc, dot(v1, v2, 1));

%// Number of points to sample between any two points on the sphere
nPoints = 100;

%// Compute the interpolant
V = zeros([nPoints, fliplr(size(v1))]);
for k = 1:numel(t)
    T = linspace(0, t(k), 100);
    V(:,k,:) = (v1(:,k) * cos(T) + v3(:,k) * sin(T)).';    %'
end

%// Break the result out into x,y,z parts
xx = V(:,:,1);
yy = V(:,:,2);
zz = V(:,:,3);

%// Plot the lines
h = plot3(xx(:), yy(:), zz(:));
hold on

%// Plot the original data points
plot3(x,y,z, 'o', ...
    'Color', get(h, 'Color'), ...
    'Parent', get(h, 'Parent'));
end


%% function to generate averaged profile of a line on an image

function [distance,avgprofile] = avgline(linedrawn,myimage,num)

vector = [linedrawn(2:end,:)-linedrawn(1:end-1,:)];
th = cart2pol( vector(:,1) ,vector(:,2)  );

[deltaxn,deltayn] = pol2cart(th-pi/2,1);
[deltaxp,deltayp] = pol2cart(th+pi/2,1);

deltaxn = [deltaxn;deltaxn(end)]; deltayn = [deltayn;deltayn(end)];
deltaxp = [deltaxp;deltaxp(end)]; deltayp = [deltayp;deltayp(end)];

linen = linedrawn + [deltaxn,deltayn]; %lines on either side of my current line
linep = linedrawn + [deltaxp,deltayp];

[cx,cy,intensity] = improfile(myimage,linedrawn(:,1),linedrawn(:,2),num);
[cx1,cy1,intensity1] = improfile(myimage,linedrawn(:,1),linedrawn(:,2),num);
[cx2,cy2,intensity2] = improfile(myimage,linedrawn(:,1),linedrawn(:,2),num);

avgprofile = [intensity , intensity1 , intensity2 ];
avgprofile = mean(intensity,2);

% while you're at it calculate distance covered by the line you drew

vect = [cx(2:end)-cx(1:end-1) , cy(2:end)-cy(1:end-1)];

[~,r] = cart2pol(vect(:,1),vect(:,2));

distance = cumsum(r);
distance = [0; distance];

end

%% fill matrix with cables

function [myimage] = fillcables(myimage,cable)

cable = round(cable); cable(cable==0)=100; %adjust cable values

xs = cable(1:2:end); ys = cable(2:2:end);

for ii = 1:numel(xs), myimage(xs(ii),ys(ii)) = 1; end

end


%% 2d Gaussian fit to data

function [fitresult, gof] = createFit(myx, myy, smallsquare,ii)

[xData, yData, zData] = prepareSurfaceData( myx, myy, smallsquare );

% Set up fittype and options.
ft = fittype( 'a*exp( -(myx-ux)^2/(2*sig^2) -(myy-uy)^2/(2*sig^2) ) + unif', 'independent', {'myx', 'myy'}, 'dependent', 'z' );
opts = fitoptions( 'Method', 'NonlinearLeastSquares' );
opts.Display = 'Off';
opts.StartPoint = [ max(smallsquare(:)) , 1 , 100 , 9 , 9 ];
opts.Robust = 'LAR';
opts.Lower = [max(smallsquare(:))*0.7 0.8 0 0 0];
%opts.Upper = [Inf 3 Inf Inf Inf]; %set fit bounds

% Fit model to data.
[fitresult, gof] = fit( [xData, yData], zData, ft, opts );

% Plot fit with data.
subplot(4,4,ii)
plot( fitresult, [xData, yData], zData );
% Label axes
xlabel myx
ylabel myy
zlabel smallsquare
grid on
view( -34.5, 4.1 );

end


%% simple displacement finder

function [c] = Function_find_dist(a,b)

c = sqrt(sum((a - b).^2 , 2 ));

end

%% sample from normal + uniform distribution

function [b] = Function_sample_normal_uniform( amp , sigma , uni )

upperlimit = amp*exp( -(0)^2/(2*sigma^2) ) + uni;

a = 1;
upperbound = 0;

while a > upperbound %keep sampling b till Function(b) < a
    
    
    a = rand()*upperlimit; %sample for a value between 0 and max of distribution
    b = rand()*2*pi - pi; %sample to pick point along x axis between pi and -pi
    upperbound = amp*exp( -(b).^2/(2*sigma^2) ) + uni;
    
end

end

%% Function to diffuse particle on surface of a sphere

function [storedpath ] = Function_sphere_walk(dist , ang , storedpath, stepnum, cellradius )
%Function_sphere_walk Makes a point do a random walk on a sphere of radius r. The point's step size per time step (dt) is sampled from a normal distribution.
%   storedpath contains cartesian coordinates of path. vectr is the
%   matrix or real number that determines how far a particle move in a given
%   timestep. diffangs is a matrix or real number that determines what
%   angle the spot will take wrt to its previous movement. stepnumb is what
%   step in the simulation this is in

%% first move last to points to the north pole so calculations are easy

northpole = [0 0 cellradius];
prevpoint = storedpath(stepnum-1,:);

normvect2pole = cross(prevpoint,northpole); normvect2pole = normvect2pole/norm(normvect2pole);%find normal vector to north pole

if stepnum>2, pointstomove = storedpath( (stepnum-2) : (stepnum-1) , : ); %these are the points you want to move to pole to generate where the patch will be in the next time step
else, pointstomove = storedpath(stepnum-1,:);
end

v = pointstomove; k = normvect2pole.*ones(size(pointstomove,1),3); % k is the vector you are carrying out rodriquez rotation around

[~,rottopole,~] = cart2sph(pointstomove(end,1),pointstomove(end,2),pointstomove(end,3));
rottopole = pi/2-rottopole; %so you rotate toward the north pole

pointstomove = v*cos(rottopole) + cross(k,v)*sin(rottopole) + k.*dot(k,v,2)*(1-cos(rottopole)); %apply Rodriguez transform to move point(s) to the pole

moveby = dist/cellradius; %express how much you want to move in radians

if size(pointstomove,1) == 2, [prevangle , ~, ~] = cart2sph(pointstomove(1,1),pointstomove(1,2),pointstomove(1,3)); %you can only have prevangle wrt to previous point
else prevangle = rand()*2*pi; %if there is no previous point, simply pick an angle at random
end

%% now make point 'walk'

newpoint = [prevangle+pi,pi/2-moveby,cellradius];
[newx , newy, newz] = sph2cart( newpoint(1) , newpoint(2) , newpoint(3) );
v = [newx , newy, newz]; k = [ 0 0 1 ];
rotaboutpole = ang; %angle you want it to move wrt to previous angle

newpoint = v*cos(rotaboutpole) + cross(k,v)*sin(rotaboutpole) + k.*dot(k,v,2)*(1-cos(rotaboutpole)); %apply Rodriguez transform to rotate point about the pole

%% now move the 'walked' point back to where it belongs

rottopole = -rottopole;
v = newpoint; k = normvect2pole;
newpoint = v*cos(rottopole) + cross(k,v)*sin(rottopole) + k.*dot(k,v,2)*(1-cos(rottopole)); %rotate newpoint back to where it should be

storedpath(stepnum,:) = newpoint;

end


